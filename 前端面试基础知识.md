# 一、JavaScript 基础

## Tips

只写总结/提炼，不写原文摘抄，带 * 为高频题



## 数据类型

### 经典问题

- 0.1 + 0.2 !== 0.3 的问题，为什么？[JavaScript 深入之浮点数精度 · Issue #155 · mqyqingfeng/Blog · GitHub](https://github.com/mqyqingfeng/Blog/issues/155)

  - 涉及精度丢失问题，并非JS语言才有这个问题
- JS 采用双精确度 64 位来储存浮点数
  - 转二进制计算时，丢失了精度；两数相加时，也丢失了精度；总共丢失三次
- 延伸：如何判断 0.1 + 0.2 与 0.3 相等？[[未知]如何判断 0.1 + 0.2 与 0.3 相等？ · Issue #10 · mqyqingfeng/frontend-interview-question-and-answer · GitHub](https://github.com/mqyqingfeng/frontend-interview-question-and-answer/issues/10)



### 类型转换



## 执行上下文 

[JavaScript深入之执行上下文栈 · Issue #4 · mqyqingfeng/Blog · GitHub](https://github.com/mqyqingfeng/Blog/issues/4)

**类型：**

- 全局上下文
- 函数上下文
- Eval上下文

**对于每个执行上下文，都有三个重要属性：**

- 变量对象(Variable object，VO)：
  - 函数的所有形参 (如果是函数上下文)
    - 没有实参，属性值设为 undefined
  - 函数声明
    - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
  - 变量声明
    - 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
- 作用域链(Scope chain)，[JavaScript深入之作用域链 · Issue #6 · mqyqingfeng/Blog · GitHub](https://github.com/mqyqingfeng/Blog/issues/6)
  - 当查找变量的时候，当前上下文的变量对象 -> 父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象，这样由多个执行上下文的变量对象构成的链表就叫做作用域链
- this



### 函数上下文

- 变量对象初始化只初始化 Arguments 对象

- 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值

- 在代码执行阶段，会再次修改变量对象的属性值
  - **函数声明跟变量声明的区别：**
    
    - 优先处理函数声明，其次处理变量声明
    
      ```javascript
      console.log(foo); // 会打印函数，而不是 undefined
      
      function foo(){
          console.log("foo");
      }
      
      var foo = 1;
      ```
    
    - 函数遇到同名属性，会替换这个属性
    
    - 变量遇到同名形参或函数，不会替换这个属性



## 闭包

[JavaScript深入之闭包 · Issue #9 · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/issues/9)

**定义**：能访问其他函数内变量（自由变量）的函数

> - 是一个函数
> - 函数能访问另外一个函数作用域中的变量

**实践角度定义：**

> - 在代码中引用了自由变量
> - 即使创建它的上下文已经销毁，它依然存在

**有什么特性？优点和缺点是什么？**，[Front-End-Interview/05.JavaScript/js.md at master · lf2021/Front-End-Interview (github.com)](https://github.com/lf2021/Front-End-Interview/blob/master/05.JavaScript/js.md#闭包的特性以及优缺点)

- **特性：**
  1. 内部函数使用外部函数的参数和变量
  2. 参数和变量不会被垃圾回收机制回收

- **优点**：
  1. 能让一个变量长期保存在内存中
  2. 避免全局污染
- **缺点：**
  1. 可能会造成内存泄漏

**闭包有什么应用场景吗？**

1. 节流、防抖函数
2. 模拟构造函数私有属性
3. React hooks，https://www.freecodecamp.org/chinese/news/react-hooks-how-to-elegantly-leverage-closures/

**说说 react hook 闭包陷阱？**，https://juejin.cn/post/7230819482012237861



## 垃圾回收机制

- 回收两种策略，https://blog.csdn.net/welnee/article/details/108721011

- 内存泄漏如何检查？[js 内存泄漏场景、如何监控以及分析 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904048961781774#comment)



## 原型 & 原型链

[JavaScript深入之从原型到原型链 · Issue #2 · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/issues/2)

**原型定义：**每个js对象创建的时候，都会关联一个对象，那就是原型对象，每个对象会从原型继承属性



## 继承

[JavaScript常见的六种继承方式 · Issue #20 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/20)

原型链继承、构造函数继承、寄生组合继承、class类继承

- 原型链继承：不能给父类函数传参
- 构造函数继承：可以给父类传参。但是只继承了父类实例的属性和方法，没有继承父类原型的属性和方法
- 寄生组合继承为什么是最好的继承？解决了上面两个继承的缺点
- class类继承实际上就是寄生组合继承，是语法糖

- 手写继承



## 深浅拷贝

- 手写
- 区别
- 深拷贝循环引用问题怎么解决？，[javascript - 如何写出一个惊艳面试官的深拷贝? - code秘密花园 - SegmentFault 思否](https://segmentfault.com/a/1190000020255831#item-6)



## 异步请求

- Ajax
- Fetch
- Async / await
- Promise



## Promise

[ES6 系列之我们来聊聊 Promise · Issue #98 · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/issues/98)

- Promise 有什么局限性？
  - 无法取消
  - 无法得知pending状态
- promise 执行过程是怎样的？
- 手写 promise
- 红绿灯问题，promise实现
- 代码输出题



## 事件循环

[浏览器与Node的事件循环(Event Loop)有何区别? · Issue #54 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/54)

[面试题：说说事件循环机制(满分答案来了) (qq.com)](https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649826653&idx=1&sn=9e5e2de78a8ef4de3820769ff3ab7c02&chksm=f175ef9ec60266880a86f33085ff43f95e3180846c5f139cb9b1b33c3245201157f39d949e9a&mpshare=1&scene=24&srcid=0731PyPfVCiYLirxXQzmyTos&sharer_sharetime=1596124967112&sharer_shareid=456144a8bde0ec265763078ba4ac8274&key=703f92d427ffe9d1caa0c4998abbec0414e3f690740b98d2b9b15bc05eedf96f3d275c91ce32b01ad3a2c8c8999c195aeafa8deeef163a6e521bf6e8eab026f0c0d68895067c9ec7e578429d602761e1&ascene=14&uin=MjA0ODUzNDYwNQ%3D%3D&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=A9P1h91IWucdTdI%2Bs6D9gAg%3D&pass_ticket=Q%2FDZNrMZlnmsWO58rP2bmESP72ns2CN3BBwZ6wzyHwcQY0MhMmBsxFYLNbHfxq2z)

- 浏览器 & node，区别是什么？

- 事件循环过程是怎样的？

- 代码输出题，https://segmentfault.com/a/1190000039819691

  - 注意：await 跟的是一个异步函数的调用的话，下面的代码将会最后进入微任务队列

  - ```javascript
    async function async1() {
        await async2()
        console.log('async1 end') // await后面返回promise异步，所以这个会最后进入微任务队列
    }
    async function async2() {
        console.log('async2 end')
        return Promise.resolve().then(()=>{
            console.log('async2 end1')
        })
    }
    async1()
    ```

  - ``````javascript
    async function async2() {
        console.log('async2 end')
        new Promise.resolve().then(()=>{ // 没有返回异步，await下面的代码在这个执行完后进队列
            console.log('async2 end1')
        })
    }



## DOM 事件机制

[DOM事件机制 · Issue #44 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/44)

- DOM 事件级别
- 事件流
- 事件代理（委托）
  - 事件冒泡到父节点，父节点的监听函数统一处理
  - 什么原理？应用场景是什么？



## ES6 新特性

https://www.jianshu.com/p/ac1787f6c50f

[ES6核心特性 · Issue #10 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/10)

### let、const

- 与 var 的区别是什么？，https://blog.csdn.net/welnee/article/details/108687946



### Map、Set

- map跟普通对象区别是什么？，https://blog.csdn.net/qq_34629352/article/details/104192870
- map为什么在频繁增删键值对的场景表现的比普通对象好？
  - map不需要把所有的键转换为字符串，节省了大量的性能

- map和Weakmap区别是什么？，[ES6 系列之 WeakMap · Issue #92 · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/issues/92)
  - weakmap只接受对象作为key
  - weakmap是弱引用
    - 什么是弱引用？只要所引用的对象的其他引用都被清除，那这个引用也会被清除
  - api上有区别：
    1. 不能遍历
    2. 没有 size 属性
- Weakmap的应用场景是什么？可以做数据缓存，因为不需要关心key什么时候会被清除



### 箭头函数 *

[ES6 系列之箭头函数 · Issue #85 · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/issues/85)

- 箭头函数跟普通函数区别是什么？，https://blog.csdn.net/welnee/article/details/108749259
  - 箭头函数 this 可以改变吗？不能，因为没有 this；this 绑定的是最近一层非箭头函数的this
  - 箭头函数没有 arguments 对象，那怎么获取箭头函数里的所有参数？
    - 可以通过 rest 参数形式获取，`let nums = (...nums) => nums;`
  - 为什么不能用 new 调用箭头函数？
    - 没有原型，也就是没有 prototype 属性。new 调用的时候会用到 prototype 赋值给新对象的 `__proto__`属性，这里会报错
    - 手写实现 new



### Spread / Rest 操作符

- 每个函数最多只能声明一个 rest 参数，而且 rest 参数必须是最后一个参数



### 解构赋值



### for...in 和 for...of



### class 类



### 函数参数默认值



### 模版字符串



### ES6 模块化





# 二、CSS

### 盒模型

[面试官：说说你对盒子模型的理解?](https://vue3js.cn/interview/css/box.html)

- 标准盒模型
  - 盒子总宽度 = width + padding + border + margin
  - `width / height` 只是内容高度，不包含 `padding` 和 `border` 值
- IE 盒模型
  - 盒子总宽度 = width + margin
  - `width / height` 包含了 `padding` 和 `border` 值
- box-sizing 属性
  - 定义了引擎如何计算一个元素的总宽度和总高度
  - 默认值 content-box，与标准盒模型表现一致
  - border-box，与IE盒模型表现一致



### 选择器

[面试官：css选择器有哪些？优先级？哪些属性可以继承？](https://vue3js.cn/interview/css/selector.html)

- 常用选择器有哪些？
  - id选择器（#box），选择id为box的元素
  - 类选择器（.one），选择类名为one的所有元素
  - 标签选择器（div），选择标签为div的所有元素
  - 后代选择器（#box div），选择id为box元素内部所有的div元素
  - 子选择器（.one > one_1），选择父元素为 .one 的所有 .one_1 的元素
  - 群组选择器（ div,p ），选择div、p的所有元素
- 选择器的优先级是怎样的？
  - 内联样式 > ID选择器 > 类选择器 > 标签选择器
  - 如果外部样式需要覆盖内联样式，就需要使用 `!important`



### BFC

[面试官：谈谈你对BFC的理解？](https://vue3js.cn/interview/css/BFC.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88)

- BFC 是什么？
  - BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素
- 怎么触发/创建 BFC？
  1. 浮动元素：float 值为 left、right
  2. display 的值为 flex、table 等等
  3. position 的值为 absolute 或 fixed
  4. overflow值不为 visible，为 auto、scroll、hidden
- 应用场景有哪些？
  - 清除浮动，`overflow: hidden`
  - 自适应多栏布局



### Flexbox（弹性盒布局模型）

[面试官：说说flexbox（弹性盒布局模型）,以及适用场景？](https://vue3js.cn/interview/css/flexbox.html)

- 常用**容器属性**有哪些？
  - flex-direction，决定主轴方向
  - flex-wrap，决定容器内项目是否可换行
  - justify-content，决定主轴对齐方式
  - align-items，决定交叉轴对齐方式
- 常用**容器成员属性**有哪些？
  - order，指定项目的排列顺序，值越小，越靠前
  - flex-grow，定义项目的放大比例（容器宽度 > 元素总宽度时如何伸展）
  - flex-shrink，定义了项目的缩小比例（容器宽度 < 元素总宽度时如何收缩）
  - flex-basis，设置的是元素在主轴上的初始尺寸
  - align-self，可以设置单个项目的对齐方式
- flex 简写
  - `flex` 属性是 `flex-grow` , `flex-shrink` 和 `flex-basis ` 的简写，默认值为 `0 1 auto`
  - flex: 1 = flex: 1 1 0，等分剩余空间



### 重排重绘

[面试官：怎么理解回流跟重绘？什么场景下会触发？](https://vue3js.cn/interview/css/layout_painting.html)

- 什么是重排重绘？
  - 重排是重新计算元素尺寸位置，重新布局页面，可能需要重新构建render树
    - offsetTop 会引起重排
  - 重绘是更新元素的外观，不影响布局
    - 在绘制阶段对已有的render树进行修改
- 如何减少重排重绘？
  1. 使用 `transform` 和 `opacity` ，通常只会引起重绘而不会引起重排
  2. 减少强制同步布局，使用 `requestAnimationFrame`
     - 什么是强制同步布局？
       - 通常发生在js代码中，试图读取布局信息时，浏览器会强制执行布局操作，确保获取到最新布局信息
     - 什么是 requestAnimationFrame？
       - 就是在下一次屏幕渲染之前执行回调函数
  3. 合理使用 React.memo（原理
  4. 虚拟列表**（配合项目讲**



### 布局

- **元素水平垂直居中的方法有哪些？**

  [面试官：元素水平垂直居中的方法有哪些？如果元素不定宽高呢？](https://vue3js.cn/interview/css/center.html#%E4%B8%80%E3%80%81%E8%83%8C%E6%99%AF)

  1. flex布局
  2. 绝对定位 + transform
  3. line-height + text-align

- **如何实现两栏布局，右侧自适应？三栏布局，中间自适应？**

  [面试官：如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？](https://vue3js.cn/interview/css/column_layout.html)

  - 两栏布局
    - float
      1. float 左浮左边栏
      2. 右侧模块使用 margin-left 撑出内容
      3. 父级添加 BFC，overflow: hidden，防止下方元素飞到上方
    - flex
      1. 左侧固定宽度
      2. 右侧 flex: 1
  - 三栏布局
    - flex 布局
      1. 父容器设置 `justify-content: space-between`
      2. 左右两侧定宽
      3. 中间设置 `width=100%` 或者 `flex: 1`
    - 左右模块绝对定位 + 中间 margin

- **怎么做响应式布局（自适应）？**

  [面试官：什么是响应式设计？响应式设计的基本原理是什么？如何做？](https://vue3js.cn/interview/css/responsive_layout.html)

  - 基本原理是什么？

    - 通过媒体查询检测不同尺寸的设备做处理

  - 怎么做？

    1. meta 标签声明 `viewport`，控制页面在移动设备的显示

       <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    2. vw / vh

       - px转vw/vh，根据各标准屏幕宽度转换，如 768px（ipad），为：实际宽度/768 * 100 vw

    3. rem

       - 根据宽度大小调整根元素的 `font-size`，编写时直接换算成 rem

    4. 监听手机旋转的事件 `orientationchange`，触发时重新计算 font-size

  - 图片怎么做响应式布局？

    1. 媒体查询不同屏幕尺寸使用不同图片
    2. 通过img标签 `srcset` 属性定义不同像素设备下图片缩略图，如 1x 2x 3x，`src` 属性作为兜底

- **隐藏 CSS 元素可以用哪些方式？**

  [面试官：css中，有哪些方式可以隐藏页面元素？区别?](https://vue3js.cn/interview/css/hide_attributes.html)

  - display: none
    - 不再占据空间，会触发重排重绘
  - visibility: hidden
    - 仍然占据空间，不触发重排会触发重绘
  - opacity: 0
    - 仍然占据空间，不引发重排可能会引发重绘（不一定引起重绘），可以响应点击事件



### 常见面试题

- CSS 提高性能的方法有哪些？，[面试官：如果要做优化，CSS提高性能的方法有哪些？](https://vue3js.cn/interview/css/css_performance.html#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80)
  - 异步加载
  - 压缩资源
  - 减少重排重绘
- 如何画一个三角形？，[面试官：CSS如何画一个三角形？原理是什么？](https://vue3js.cn/interview/css/triangle.html)





# 三、浏览器

### 渲染

- 为什么操作 DOM 慢？

  - 操作 DOM 会引起重排重绘

  - DOM 属于渲染引擎，JS 属于 JS 引擎，两个引擎通信需要开销

    

### 跨域

[九种跨域方式实现原理（完整版） · Issue #55 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/55)

https://blog.csdn.net/welnee/article/details/108733996

- 什么是跨域？
- 解决跨域有哪些方法？
  - Nginx
  - CORS
  - jsonp
- CORS 的原理是什么？



### 存储

[浏览器存储 · Issue #25 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/25)

- cookie
  - cookie 和 session 区别是什么？，[Cookie和Session的区别 - 简书 (jianshu.com)](https://www.jianshu.com/p/2f7031a69f43)
    1. 存储位置不同
    2. 存储方式不同
    3. 有效期不同
  - 缺陷是什么？每个cookie大小限制为4kb，每个站点存储的数量也有限制
- sessionStorage
  - 不同标签页是否能共享？不能，https://juejin.cn/post/7232674707349880888
- localStorage
- indexedDB
- 以上四个的区别是什么？



### 缓存

[深入理解浏览器的缓存机制 · Issue #23 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/23)

[深入浅出浏览器缓存机制 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903757872889870)

- 强缓存
  - 判断是否缓存的依据来自于是否超出某个时间或者某个时间段，可以通过设置两种 http header 来实现：
  - **Expires**
    - 响应头字段
    - 有什么缺点？受限于本地时间，修改本地时间可能会造成缓存失效
  - **Cache-Control**
    - 请求头或者响应头中都可以设置
    - no-cache 和 no-store 区别？前者是使用协商缓存，后者是不使用缓存
  - Expires 和 Cache-Control 有什么区别？
    1. Expires 是http1.0的产物，Cache-Control是http1.1的产物
    2. Cache-Control 优先级高于 Expires
- 协商缓存
  - 强缓存失效后，浏览器携带缓存标识发起请求，由服务器根据标识决定是否使用缓存。可以通过设置两种 http header 来实现：
  - **Last-Modified**
    - 响应头字段，值是这个资源在服务器上的最后修改时间
    - 配合 If-Modified-Since 请求头使用
    - 有什么缺点？
      1. 打开缓存文件没有修改，也会造成 Last-Modified 被修改
      2. 精度问题，时间单位是秒，1秒内完成修改文件， Last-Modified 不会被修改
  - **ETag**
    - 响应头字段，返回当前资源文件的一个唯一标识，只要服务端资源有变化，Etag 就会重新生成
    - 浏览器请求时会将上次返回的Etag值放到请求头的 If-None-Match 里
  - Last-Modified 和 Etag 的区别在哪里？
    1. 精度上，Etag 优于 Last-Modified 
    2. Etag 优先级比 Last-Modified 高
  - 只用 ETag 不用 last-modify 行不行？，https://juejin.cn/post/7291133929364308024
    - 可能存在兼容性问题
- 实际应用场景有哪些？
  - last-modified 可用于修改不频繁的资源
  - Etag 可用于修改频繁或改动不大的资源




### 安全

https://blog.csdn.net/welnee/article/details/109555231

[常见六大Web安全攻防解析 · Issue #56 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/56)

- XSS（跨站脚本攻击）
  - 有两种类型：
    - 非持久性，带有恶意脚本代码参数的 url 被打开来触发
    - 持久性，通过 form 表单提交带有恶意脚本代码的内容存储在后端，当页面从后端获取数据后被渲染执行
  - 如何防御？
    1. CSP（http header 中的 Content-Security-Policy）
    2. 转义输入输出字符，主要处理 `< 、 > 、 / 、" ` 等字符
       - 对于富文本，可通过库配置哪些标签保留，哪些标签过滤。**（项目中使用了 dompurify 库，可延伸此内容**
    3. cookie 设置 HttpOnly 属性，阻止js操作cookie
- CSRF（跨站请求伪造）
  - https://tech.meituan.com/2018/10/11/fe-security-csrf.html
  - **支付业务团队可能会详细问**
  - 利用用户已登陆身份，以用户名义完成非法操作
  - 如何防御？
    1. XSRF Token，https://blog.csdn.net/m0_57236802/article/details/132259004
       - X-XSRF-TOKEN 和 X-CSRF-TOKEN 有什么区别？https://www.xbnb.cn/8868
       - 每个会话设置一个随机值的cookie，即 xsrf-token（请求时携带 x-xsrf-token 请求头
    2. cookie 设置 SameSite 属性，阻止跨域请求
       - 有 Lax、Strict 两个值，Lax只在 get 请求携带cookie，Strict 任何时候都不携带
       - 不支持子域，跳转到子域页面需要重新登陆
    3. 验证码，例如支付场景
- 点击劫持
  - 如何防御？设置 X-FRAME-OPTIONS 响应头
- SQL注入



### 性能优化

https://alienzhou.github.io/fe-performance-journey/

- **1）缓存阶段**

  - localStorage、sessionStorage、indexedDB
    - 例如 localStorage 可以设置过期时间，缓存接口数据（例如一些活动页面
  - HTTP 缓存（强缓存、协商缓存）
    - meta 标签指定缓存策略

- **2）发送请求阶段**

  - 使用 CDN

- **3）服务端响应阶段**

  - BFF**（结合项目 GraphQL 讲**

- **4）页面解析处理阶段**

  https://alienzhou.github.io/fe-performance-journey/5-subresources/

  - **JS**

    - 按需加载模块
      1. React.lazy 按需加载
      2. UI 库按需加载
         - 不直接引用整个库，按需引入
    - 减小打包体积
      1. Gzip 压缩（可在Nginx做，也可在webpack配置 `compression-webpack-plugin` 来做
      2. 压缩js代码，通过 [`TerserWebpackPlugin`](https://v4.webpack.docschina.org/plugins/terser-webpack-plugin/)  配置**（这里可能会问 Tree Shaking 原理**
         - 原理？1、构建 AST	2、压缩	3、混淆
    - 拆包缓存，[webpack-缓存](https://alienzhou.github.io/fe-performance-journey/5-subresources/javascript.html#_4-%E7%BC%93%E5%AD%98)
      1. 将**基础库（UI库、第三方库）**单独打包，通过webpack的 [`optimization.splitChunks`](https://webpack.docschina.org/plugins/split-chunks-plugin/#optimizationsplitchunks) 配置
      2. 将 **运行时代码** 单独拆开，通过 [`optimization.runtimeChunk`](https://webpack.js.org/configuration/optimization/#optimizationruntimechunk) 配置

  - **CSS**

    [面试官：如果要做优化，CSS提高性能的方法有哪些？](https://vue3js.cn/interview/css/css_performance.html)

    - 压缩 CSS 代码，通过 [`optimize-css-assets-webpack-plugin`](https://github.com/NMFR/optimize-css-assets-webpack-plugin) 配置
    - 缓存
      - 使用 [MiniCssExtractPlugin](https://webpack.js.org/plugins/mini-css-extract-plugin/) 插件单独抽离出 CSS 文件

  - **图片（图片场景多的业务可能会细问**

    - 减少请求
      1. 雪碧图，减少请求
      2. 懒加载，https://juejin.cn/post/7196970992576397367
         - [Intersection Observer ](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver)
           - 项目中可使用 [react-intersection-observer](https://github.com/thebuilder/react-intersection-observer)
         - [getBoundingClientRect](https://developer.mozilla.org/zh-CN/docs/Web/API/Range/getBoundingClientRect)
         - 图片抖动问题如何解决？设置占位图
      3. base64内联（通过 `url-loader` 配置
    - 减小体积
      - 转 WebP 格式
        1. accept 请求头要有webp格式，浏览器支持WebP格式则转
        2. 定义有损压缩比例

  - 字体

  - 视频

- **5）运行时阶段**

  https://alienzhou.github.io/fe-performance-journey/6-runtime/

  - 长列表优化
    - 虚拟滚动**（结合项目讲**

- **6）预加载**

- **首屏加载性能如何优化？**，[https://vue3js.cn/interview/vue/first_page_time.html](面试官：SPA首屏加载速度慢的怎么解决？)
  - 两大方面：资源加载优化 和 页面渲染优化
    1. **缓存阶段**
    2. **服务器响应阶段**
       - SSR
    3. **页面解析阶段**
       - JS
       - CSS
       - 图片（首屏不需要懒加载
         1. 雪碧图
         2. 转成 WebP 格式
         3. 内联base64



### 经典面试题

- 从URL输入到页面展现到底发生什么？

  [从URL输入到页面展现到底发生什么？ · Issue #24 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/24)

  [面试官：说说地址栏输入 URL 敲下回车后发生了什么?](https://vue3js.cn/interview/http/after_url.html#%E4%B8%80%E3%80%81%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90)

  - DNS解析，[面试官：DNS协议 是什么？说说DNS 完整的查询过程?](https://vue3js.cn/interview/http/DNS.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88)
    - DNS 怎么解析？DNS 污染什么意思？
    - 先查缓存，再查本地域名服务器 -> 根服务器 -> 顶级域名服务器 -> 权限域名服务器...
  - TCP连接
    - 为什么是三次握手？，https://blog.csdn.net/welnee/article/details/109153129
  - HTTP请求
    - [请求头有哪些固定的？](#http-header)
    - [请求类型有哪些？](#request-type)
  - HTTP响应
    - [常见的状态码有哪些？](#response-code)
  - 浏览器解析渲染
    1. 首先对资源解析
       - 查看响应头，根据指令做操作，如重定向、存储cookie、解压gzip等
       - 根据响应头的 `Content-type` ，采用不同的解析方式
    2. 页面渲染，[你不知道的浏览器页面渲染机制 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903815758479374)
       1. 解析html，构建 DOM 树
       2. 解析CSS，生成 CSS 规则树
       3. 合并 DOM 树和 CSS 规则树，生成 render 树
          - 解析css会阻塞js脚本，js脚本会阻塞html解析
       4. 布局 render 树，负责各元素尺寸、位置的计算
          - 重排需要重新构建 render 树，重绘只需要在绘制阶段对已有的 render 树进行修改
       5. 绘制 render 树
          - 生成一系列的图层，每个图层对应渲染树的一个节点，每个图层包含元素的绘制信息（位置、大小）
       6. 合成图层（composite），[淘系前端 - 无线性能优化：Composite](https://fed.taobao.org/blog/2016/04/26/performance-composite/)
          - GPU 会合成绘制生成的一系列图层，显示在屏幕上
  - 关闭TCP连接
    - 四次挥手
    - 谁关闭 TCP 连接？客户端和服务器都可以





# 四、网络

### HTTP / HTTPS

[关于Http协议，你必须要知道的 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903619343581191)

- 网络模型
  - http 协议处于哪层，解决什么问题？应用层
  - 网络层和传输层解决什么问题？
  
- <span id="response-code">状态码</span> ，[说说HTTP 常见的状态码有哪些，适用场景？](https://vue3js.cn/interview/http/status.html#%E9%9D%A2%E8%AF%95%E5%AE%98-%E8%AF%B4%E8%AF%B4http-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF)

  - 101，切换协议，如切换到websocket协议
  - 206，请求部分内容时会返回，响应头包含 `Content-Range` 字段，常用于大文件上传，断点续传
  - 3xx
    - 301
    - 302，临时重定向，可用于登陆注册、移动设备识别等
    - 304，协商缓存
  - 4xx
    - 401，未授权，需要身份凭证，登陆场景可能会返回
    - 403，通过身份认证，但是没有权限，访问被拒绝
    - 404
  - 5xx
    - 500，服务器内部错误
    - 502，服务器无响应
    - 504，服务器超时

-  <span id="http-header">请求头有哪些固定的？</span>

  - Host、User-Agent、Cookie、Connection、Content-type...

- <span id="request-type">请求类型有哪些？</span>

  - get、post、put、patch、delete...
  - get和post区别是什么？
    1. get会被缓存，post不会，除非手动设置
       - get 缓存原理是什么？强缓存、协商缓存
       - 如何永远不缓存？请求带上随机生成的参数，如`?timestamp=161234567890`

    2. get在url上传送的参数有长度限制，post没有
    3. get参数通过url传递，post通过请求体传递

- **http 请求流程是怎样的？**

  1. DNS解析
  2. 建立TCP连接
  3. 发送http请求
  4. 服务器处理返回响应
  5. 浏览器接收响应
  6. 关闭TCP连接

- **http 缓存**

  - 强缓存、协商缓存

- **http2 与 http1.x 区别是什么？**

  [解密HTTP/2与HTTP/3 的新特性 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903968380813325)

  [面试官：说说 HTTP1.0/1.1/2.0 的区别?](https://vue3js.cn/interview/http/1.0_1.1_2.0.html)

  - HTTP1.0
    - 不支持长连接
    - 1.0版本如何在一次连接中进行多次请求？Connection字段改成非 close 的值

  - HTTP1.1
    - 默认支持长连接，请求头和响应头带有 `Connection: Keep-Alive`
    - 引入更多缓存控制策略（结合协商缓存

  - HTTP2
    1. 二进制传输
       - 帧形式传输，可以乱序发送，最后根据帧头部标识组装数据

    2. header压缩
       - 建立字典记录发送过的header，只发送差异header

    3. 多路复用
       - 同一个域名用一个TCP连接处理所有请求，服务器和浏览器可以同时发送多个请求和响应

    4. 服务端推送（可以跟性能优化一起讲
       - 原理，https://juejin.cn/post/6909714903393796103
       - 实践：https://mp.weixin.qq.com/s/d11OJ6iepqI2kJ9tczGYBQ
       - 一定能提升性能吗？什么场景可能会造成加载更慢？
         1. 浏览器缓存
         2. 资源加载优先级
         3. TCP 慢启动

- **https 和 http 区别是什么？**

  https://blog.csdn.net/welnee/article/details/108620238

  [面试官：什么是HTTP? HTTP 和 HTTPS 的区别?](https://vue3js.cn/interview/http/HTTP_HTTPS.html#%E4%B8%80%E3%80%81http)

  - http 使用明文传输，https 加密传输
  - 端口不一样，http 使用80端口，https 使用443端口
  - http 响应更快，因为 https 需要SSL连接
  - https 需要SSL证书




### TCP、UDP

[面试官：如何理解UDP 和 TCP? 区别? 应用场景?](https://vue3js.cn/interview/http/UDP_TCP.html#%E4%B8%80%E3%80%81udp)

[TCP和UDP比较 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903800336023560)

- TCP 和 UDP 的区别是什么？
  - UDP 无连接，效率高；TCP 需要建立连接，提供可靠传输
  - UDP 没有流量控制、拥塞控制，不保证数据无丢失

- 哪些协议基于 TCP、UDP？
  - 基于TCP的有：HTTP、FTP...
  - 基于UDP的有：DNS、QUCI...

- UDP 应用场景是什么？
  - 实时应用（聊天、直播、视频会议）

- TCP 三次握手四次挥手，https://blog.csdn.net/welnee/article/details/109153129



### Websocket

[面试官：说说对WebSocket的理解？应用场景？](https://vue3js.cn/interview/http/WebSocket.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88)

- 有什么优点？
  - 实时性更强，服务器不需要等待客户端发起请求就能响应
  - 保持连接状态，创建连接后，可省略状态信息，不同于HTTP每次请求需要携带身份认证
  - 支持扩展，可实现自定义子协议
- 应用场景有哪些？
  - 弹幕
  - 媒体聊天
  - 协同编辑
  - 股票基金报价实时更新





# React

- **说说虚拟 DOM，和真实DOM 的区别？**，[面试官：说说 Real DOM 和 Virtual DOM 的区别？优缺点？](https://vue3js.cn/interview/React/Real%20DOM_Virtual%20DOM.html)

  - 什么是虚拟 DOM？
    - JS 模拟真实DOM构建出来的对象，属性一一对应
  - 区别？
    1. 虚拟DOM不会重排重绘
    2. 虚拟DOM会对比真实DOM，只会更新差异部分

- **说说React生命周期有哪些阶段，每个阶段对应的方法？**

  [面试官：说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？](https://vue3js.cn/interview/React/life%20cycle.html)

  - 创建阶段
    - constructor
    - getDerivedStateFromProps
    - render
      - 不要在 `render` 里面 `setState`，否则会触发死循环导致内存崩溃
    - componentDidMount
  - 更新阶段
    - getDerivedStateFromProps
      1. 根据路径splat判断是否更新 首页 模块state
      2. 根据分支是否改变判断是否更新 对比/创建MR 模块state
    - shouldComponentUpdate
      - 不建议在该周期方法中进行深层比较，会影响效率同时也不能调用`setState`，否则会导致无限循环调用更新
      - 项目实践：
        1. 当首页 `nextProps` 的 depot 参数为空时，重定向回原来的depot页面
    - render
    - getSnapshotBeforeUpdate
      - 获取组件更新前的一些信息，比如组件的滚动位置之类，组件更新之后可以根据这些信息恢复之前的 UI 状态
    - componentDidUpdate
  - 卸载阶段
    - componentWillUnmount

- 





# Webpack

- 搞懂项目所有loader和plugin



# TypeScript

![image-20231113024624192](/Users/welnee/Library/Application Support/typora-user-images/image-20231113024624192.png)
