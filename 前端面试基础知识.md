# 一、JavaScript 基础

## Tips

只写总结/提炼，不写原文摘抄，带 * 为高频题



## 数据类型

### 经典问题

- 0.1 + 0.2 !== 0.3 的问题，为什么？[JavaScript 深入之浮点数精度 · Issue #155 · mqyqingfeng/Blog · GitHub](https://github.com/mqyqingfeng/Blog/issues/155)

  - 涉及精度丢失问题，并非JS语言才有这个问题
- JS 采用双精确度 64 位来储存浮点数
  - 转二进制计算时，丢失了精度；两数相加时，也丢失了精度；总共丢失三次
- 延伸：如何判断 0.1 + 0.2 与 0.3 相等？[[未知]如何判断 0.1 + 0.2 与 0.3 相等？ · Issue #10 · mqyqingfeng/frontend-interview-question-and-answer · GitHub](https://github.com/mqyqingfeng/frontend-interview-question-and-answer/issues/10)



### 类型转换



## 执行上下文 

[JavaScript深入之执行上下文栈 · Issue #4 · mqyqingfeng/Blog · GitHub](https://github.com/mqyqingfeng/Blog/issues/4)

**类型：**

- 全局上下文
- 函数上下文
- Eval上下文

**对于每个执行上下文，都有三个重要属性：**

- 变量对象(Variable object，VO)：
  - 函数的所有形参 (如果是函数上下文)
    - 没有实参，属性值设为 undefined
  - 函数声明
    - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
  - 变量声明
    - 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
- 作用域链(Scope chain)，[JavaScript深入之作用域链 · Issue #6 · mqyqingfeng/Blog · GitHub](https://github.com/mqyqingfeng/Blog/issues/6)
  - 当查找变量的时候，当前上下文的变量对象 -> 父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象，这样由多个执行上下文的变量对象构成的链表就叫做作用域链
- this



### 函数上下文

- 变量对象初始化只初始化 Arguments 对象

- 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值

- 在代码执行阶段，会再次修改变量对象的属性值
  - **函数声明跟变量声明的区别：**
    
    - 优先处理函数声明，其次处理变量声明
    
      ```javascript
      console.log(foo); // 会打印函数，而不是 undefined
      
      function foo(){
          console.log("foo");
      }
      
      var foo = 1;
      ```
    
    - 函数遇到同名属性，会替换这个属性
    
    - 变量遇到同名形参或函数，不会替换这个属性



## 闭包

[JavaScript深入之闭包 · Issue #9 · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/issues/9)

**定义**：能访问其他函数内变量（自由变量）的函数

> - 是一个函数
> - 函数能访问另外一个函数作用域中的变量

**实践角度定义：**

> - 在代码中引用了自由变量
> - 即使创建它的上下文已经销毁，它依然存在

**有什么特性？优点和缺点是什么？**，[Front-End-Interview/05.JavaScript/js.md at master · lf2021/Front-End-Interview (github.com)](https://github.com/lf2021/Front-End-Interview/blob/master/05.JavaScript/js.md#闭包的特性以及优缺点)

- **特性：**
  1. 内部函数使用外部函数的参数和变量
  2. 参数和变量不会被垃圾回收机制回收

- **优点**：
  1. 能让一个变量长期保存在内存中
  2. 避免全局污染
- **缺点：**
  1. 可能会造成内存泄漏

**闭包有什么应用场景吗？**

1. 节流、防抖函数
2. 模拟构造函数私有属性
3. React hooks，https://www.freecodecamp.org/chinese/news/react-hooks-how-to-elegantly-leverage-closures/

**说说 react hook 闭包陷阱？**，https://juejin.cn/post/7230819482012237861



## 垃圾回收机制

- 回收两种策略，https://blog.csdn.net/welnee/article/details/108721011

- 内存泄漏如何检查？[js 内存泄漏场景、如何监控以及分析 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904048961781774#comment)



## 原型 & 原型链

[JavaScript深入之从原型到原型链 · Issue #2 · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/issues/2)

**原型定义：**每个js对象创建的时候，都会关联一个对象，那就是原型对象，每个对象会从原型继承属性



## 继承

[JavaScript常见的六种继承方式 · Issue #20 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/20)

原型链继承、构造函数继承、寄生组合继承、class类继承

- 原型链继承：不能给父类函数传参
- 构造函数继承：可以给父类传参。但是只继承了父类实例的属性和方法，没有继承父类原型的属性和方法
- 寄生组合继承为什么是最好的继承？解决了上面两个继承的缺点
- class类继承实际上就是寄生组合继承，是语法糖

- 手写继承



## 深浅拷贝

- 手写
- 区别
- 深拷贝循环引用问题怎么解决？，[javascript - 如何写出一个惊艳面试官的深拷贝? - code秘密花园 - SegmentFault 思否](https://segmentfault.com/a/1190000020255831#item-6)



## 异步请求

- Ajax
- Fetch
- Async / await
- Promise



## Promise

[ES6 系列之我们来聊聊 Promise · Issue #98 · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/issues/98)

- Promise 有什么局限性？
  - 无法取消
  - 无法得知pending状态
- promise 执行过程是怎样的？
- 手写 promise
- 红绿灯问题，promise实现
- 代码输出题



## 事件循环

[浏览器与Node的事件循环(Event Loop)有何区别? · Issue #54 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/54)

[面试题：说说事件循环机制(满分答案来了) (qq.com)](https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649826653&idx=1&sn=9e5e2de78a8ef4de3820769ff3ab7c02&chksm=f175ef9ec60266880a86f33085ff43f95e3180846c5f139cb9b1b33c3245201157f39d949e9a&mpshare=1&scene=24&srcid=0731PyPfVCiYLirxXQzmyTos&sharer_sharetime=1596124967112&sharer_shareid=456144a8bde0ec265763078ba4ac8274&key=703f92d427ffe9d1caa0c4998abbec0414e3f690740b98d2b9b15bc05eedf96f3d275c91ce32b01ad3a2c8c8999c195aeafa8deeef163a6e521bf6e8eab026f0c0d68895067c9ec7e578429d602761e1&ascene=14&uin=MjA0ODUzNDYwNQ%3D%3D&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=A9P1h91IWucdTdI%2Bs6D9gAg%3D&pass_ticket=Q%2FDZNrMZlnmsWO58rP2bmESP72ns2CN3BBwZ6wzyHwcQY0MhMmBsxFYLNbHfxq2z)

- 浏览器 & node，区别是什么？

- 事件循环过程是怎样的？

- 代码输出题，https://segmentfault.com/a/1190000039819691

  - 注意：await 跟的是一个异步函数的调用的话，下面的代码将会最后进入微任务队列

  - ```javascript
    async function async1() {
        await async2()
        console.log('async1 end') // await后面返回promise异步，所以这个会最后进入微任务队列
    }
    async function async2() {
        console.log('async2 end')
        return Promise.resolve().then(()=>{
            console.log('async2 end1')
        })
    }
    async1()
    ```

  - ``````javascript
    async function async2() {
        console.log('async2 end')
        new Promise.resolve().then(()=>{ // 没有返回异步，await下面的代码在这个执行完后进队列
            console.log('async2 end1')
        })
    }



## DOM 事件机制

[DOM事件机制 · Issue #44 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/44)

- DOM 事件级别
- 事件流
- 事件代理（委托）
  - 事件冒泡到父节点，父节点的监听函数统一处理
  - 什么原理？应用场景是什么？



## ES6 新特性

https://www.jianshu.com/p/ac1787f6c50f

[ES6核心特性 · Issue #10 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/10)

### let、const

- 与 var 的区别是什么？，https://blog.csdn.net/welnee/article/details/108687946



### Map、Set

- map跟普通对象区别是什么？，https://blog.csdn.net/qq_34629352/article/details/104192870
- map为什么在频繁增删键值对的场景表现的比普通对象好？
  - map不需要把所有的键转换为字符串，节省了大量的性能

- map和Weakmap区别是什么？，[ES6 系列之 WeakMap · Issue #92 · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/issues/92)
  - weakmap只接受对象作为key
  - weakmap是弱引用
    - 什么是弱引用？只要所引用的对象的其他引用都被清除，那这个引用也会被清除
  - api上有区别：
    1. 不能遍历
    2. 没有 size 属性
- Weakmap的应用场景是什么？可以做数据缓存，因为不需要关心key什么时候会被清除



### 箭头函数 *

[ES6 系列之箭头函数 · Issue #85 · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/issues/85)

- 箭头函数跟普通函数区别是什么？，https://blog.csdn.net/welnee/article/details/108749259
  - 箭头函数 this 可以改变吗？不能，因为没有 this；this 绑定的是最近一层非箭头函数的this
  - 箭头函数没有 arguments 对象，那怎么获取箭头函数里的所有参数？
    - 可以通过 rest 参数形式获取，`let nums = (...nums) => nums;`
  - 为什么不能用 new 调用箭头函数？
    - 没有原型，也就是没有 prototype 属性。new 调用的时候会用到 prototype 赋值给新对象的 `__proto__`属性，这里会报错
    - 手写实现 new



### Spread / Rest 操作符

- 每个函数最多只能声明一个 rest 参数，而且 rest 参数必须是最后一个参数



### 解构赋值



### for...in 和 for...of



### class 类



### 函数参数默认值



### 模版字符串



### ES6 模块化





# 二、浏览器

### 跨域

[九种跨域方式实现原理（完整版） · Issue #55 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/55)

https://blog.csdn.net/welnee/article/details/108733996

- 什么是跨域？
- 解决跨域有哪些方法？
  - Nginx
  - CORS
  - jsonp
- CORS 的原理是什么？



### 存储

[浏览器存储 · Issue #25 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/25)

- cookie
  - cookie 和 session 区别是什么？，[Cookie和Session的区别 - 简书 (jianshu.com)](https://www.jianshu.com/p/2f7031a69f43)
    1. 存储位置不同
    2. 存储方式不同
    3. 有效期不同
  - 缺陷是什么？每个cookie大小限制为4kb，每个站点存储的数量也有限制
- sessionStorage
  - 不同标签页是否能共享？不能，https://juejin.cn/post/7232674707349880888
- localStorage
- indexedDB
- 以上四个的区别是什么？



### 缓存

[深入理解浏览器的缓存机制 · Issue #23 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/23)

[深入浅出浏览器缓存机制 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903757872889870)

- 强缓存
  - 判断是否缓存的依据来自于是否超出某个时间或者某个时间段，可以通过设置两种 http header 来实现：
  - **Expires**
    - 响应头字段
    - 有什么缺点？受限于本地时间，修改本地时间可能会造成缓存失效
  - **Cache-Control**
    - 请求头或者响应头中都可以设置
    - no-cache 和 no-store 区别？前者是使用协商缓存，后者是不使用缓存
  - Expires 和 Cache-Control 有什么区别？
    1. Expires 是http1.0的产物，Cache-Control是http1.1的产物
    2. Cache-Control 优先级高于 Expires
- 协商缓存
  - 强缓存失效后，浏览器携带缓存标识发起请求，由服务器根据标识决定是否使用缓存。可以通过设置两种 http header 来实现：
  - **Last-Modified**
    - 响应头字段，值是这个资源在服务器上的最后修改时间
    - 配合 If-Modified-Since 请求头使用
    - 有什么缺点？
      1. 打开缓存文件没有修改，也会造成 Last-Modified 被修改
      2. 精度问题，时间单位是秒，1秒内完成修改文件， Last-Modified 不会被修改
  - **ETag**
    - 响应头字段，返回当前资源文件的一个唯一标识，只要服务端资源有变化，Etag 就会重新生成
    - 浏览器请求时会将上次返回的Etag值放到请求头的 If-None-Match 里
  - Last-Modified 和 Etag 的区别在哪里？
    1. 精度上，Etag 优于 Last-Modified 
    2. Etag 优先级比 Last-Modified 高
  - 只用 ETag 不用 last-modify 行不行？，https://juejin.cn/post/7291133929364308024
    - 可能存在兼容性问题
- 实际应用场景有哪些？
  - last-modified 可用于修改不频繁的资源
  - Etag 可用于修改频繁或改动不大的资源




### 安全

https://blog.csdn.net/welnee/article/details/109555231

[常见六大Web安全攻防解析 · Issue #56 · ljianshu/Blog (github.com)](https://github.com/ljianshu/Blog/issues/56)

- XSS（跨站脚本攻击）
  - 有两种类型：
    - 非持久性，带有恶意脚本代码参数的 url 被打开来触发
    - 持久性，通过 form 表单提交带有恶意脚本代码的内容存储在后端，当页面从后端获取数据后被渲染执行
  - 如何防御？
    1. CSP（http header 中的 Content-Security-Policy）
    2. 转义输入输出字符，主要处理 `< 、 > 、 / 、" ` 等字符
       - 对于富文本，可通过库配置哪些标签保留，哪些标签过滤。**（项目中使用了 dompurify 库，可延伸此内容**
    3. cookie 设置 HttpOnly 属性，阻止js操作cookie
- CSRF（跨站请求伪造）
  - https://tech.meituan.com/2018/10/11/fe-security-csrf.html
  - **支付业务团队可能会详细问**
  - 利用用户已登陆身份，以用户名义完成非法操作
  - 如何防御？
    1. XSRF Token，https://blog.csdn.net/m0_57236802/article/details/132259004
       - X-XSRF-TOKEN 和 X-CSRF-TOKEN 有什么区别？https://www.xbnb.cn/8868
       - 每个会话设置一个随机值的cookie，即 xsrf-token（请求时携带 x-xsrf-token 请求头
    2. cookie 设置 SameSite 属性，阻止跨域请求
       - 有 Lax、Strict 两个值，Lax只在 get 请求携带cookie，Strict 任何时候都不携带
       - 不支持子域，跳转到子域页面需要重新登陆
    3. 验证码，例如支付场景
- 点击劫持
  - 如何防御？设置 X-FRAME-OPTIONS 响应头
- SQL注入



### 性能优化

https://alienzhou.github.io/fe-performance-journey/

- **1）缓存阶段**

  - localStorage、sessionStorage、indexedDB
  - HTTP 缓存（强缓存、协商缓存）
    - meta 标签指定缓存策略

- **2）发送请求阶段**

  - 使用 CDN

- **3）服务端响应阶段**

  - BFF**（配合项目 GraphQL 讲**

- **4）页面解析处理阶段**

  https://alienzhou.github.io/fe-performance-journey/5-subresources/

  - **JS**

    - React.lazy 按需加载模块
    - 减小打包体积
      1. gzip 压缩
      2. Tree Shaking
    - 缓存，[webpack-缓存](https://alienzhou.github.io/fe-performance-journey/5-subresources/javascript.html#_4-%E7%BC%93%E5%AD%98)
      1. 将**基础库（UI库、语法高亮库、第三方库）**单独打包，通过webpack的 [`optimization.splitChunks`](https://webpack.docschina.org/plugins/split-chunks-plugin/#optimizationsplitchunks) 配置
      2. 将 **运行时代码** 单独拆开，通过 [`optimization.runtimeChunk`](https://webpack.js.org/configuration/optimization/#optimizationruntimechunk) 配置

  - **CSS**

    [面试官：如果要做优化，CSS提高性能的方法有哪些？](https://vue3js.cn/interview/css/css_performance.html)

    - 不要使用 `@import`，影响并行下载
    - 压缩资源
    - 减少选择器嵌套，会降低样式渲染性能
    - 缓存
      - 使用 [MiniCssExtractPlugin](https://webpack.js.org/plugins/mini-css-extract-plugin/) 插件单独抽离出 CSS 文件

  - **图片**

    - 雪碧图

    - 懒加载

      1. [Intersection Observer ](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver)
      2. CSS 图片懒加载（background-url

      ```css
      .login {
          background-url: url(/static/img/login.png);
      }
      ```

      - 图片抖动问题如何解决？设置占位图

    - 图片压缩

      - 内联base64
      - 转 WebP 格式（要做兼容逻辑

    - 缓存

  - 字体

  - 视频

- **5）运行时阶段**

  https://alienzhou.github.io/fe-performance-journey/6-runtime/

  - 长列表优化
    - 虚拟滚动

- **6）预加载**

- **首屏加载性能如何优化？**，[https://vue3js.cn/interview/vue/first_page_time.html](面试官：SPA首屏加载速度慢的怎么解决？)

  - 加载慢原因？
    1. 网络时延
    2. 资源体积大
    3. 资源重复请求
    4. 渲染阻塞

  - 如何优化？两大方面：资源加载优化 和 页面渲染优化
    1. 减小入口文件体积
       - 路由懒加载
    2. 静态资源本地缓存
       - HTTP 缓存，设置`Cache-Control`，`Last-Modified`，`Etag`等响应头
       - 合理利用 localStorage
         - 可以设置过期时间，缓存接口数据（例如一些活动页面
    3. UI 库按需加载
       - 不直接引用整个库，按需引入
    4. 图片资源压缩
       - 雪碧图，减少请求
       - 转成 WebP 格式
       - 内联base64，url-loader 执行操作
    5. GZip 压缩
    6. SSR





# 三、网络

### HTTP / HTTPS

[关于Http协议，你必须要知道的 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903619343581191)

- 网络模型
  - http 协议处于哪层，解决什么问题？应用层
  - 网络层和传输层解决什么问题？
  
- 状态码，[说说HTTP 常见的状态码有哪些，适用场景？](https://vue3js.cn/interview/http/status.html#%E9%9D%A2%E8%AF%95%E5%AE%98-%E8%AF%B4%E8%AF%B4http-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF)

  - 101，websocket
  - 206，断点续传
  - 301、302、304
  - 401、403、404
  - 500、502、504

- 请求头有哪些固定的？

  - User Agent、Cookie、Content-type...

- 请求类型有哪些？

  - get、post、put、delete...
  - get和post区别是什么？
    1. get会被缓存，post不会，除非手动设置
       - get 缓存原理是什么？强缓存、协商缓存
       - 如何永远不缓存？请求带上随机生成的参数

    2. get在url上传送的参数有长度限制，post没有
    3. get参数通过url传递，post通过请求体传递

- **http 请求流程是怎样的？**

  - DNS 怎么解析？DNS 污染什么意思？
  - 谁关闭 TCP 连接？

- **http 缓存**

  - 强缓存、协商缓存

- **http2 与 http1.x 区别是什么？**

  [解密HTTP/2与HTTP/3 的新特性 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903968380813325)

  [面试官：说说 HTTP1.0/1.1/2.0 的区别?](https://vue3js.cn/interview/http/1.0_1.1_2.0.html)

  - HTTP1.0
    - 不支持长连接
    - 1.0版本如何在一次连接中进行多次请求？Connection字段改成非 close 的值

  - HTTP1.1
    - 默认支持长连接，请求头和响应头带有 `Connection: Keep-Alive`
    - 引入更多缓存控制策略（结合协商缓存

  - HTTP2
    1. 二进制传输
       - 帧形式传输，可以乱序发送，最后根据帧头部标识组装数据

    2. header压缩
       - 建立字典记录发送过的header，只发送差异header

    3. 多路复用
       - 同一个域名用一个TCP连接处理所有请求，服务器和浏览器可以同时发送多个请求和响应

    4. 服务端推送（可以跟性能优化一起讲
       - 原理，https://juejin.cn/post/6909714903393796103
       - 实践：https://mp.weixin.qq.com/s/d11OJ6iepqI2kJ9tczGYBQ
       - 一定能提升性能吗？什么场景可能会造成加载更慢？
         1. 浏览器缓存
         2. 资源加载优先级
         3. TCP 慢启动

- **https 和 http 区别是什么？**

  https://blog.csdn.net/welnee/article/details/108620238

  [面试官：什么是HTTP? HTTP 和 HTTPS 的区别?](https://vue3js.cn/interview/http/HTTP_HTTPS.html#%E4%B8%80%E3%80%81http)

  - http 使用明文传输，https 加密传输
  - 端口不一样，http 使用80端口，https 使用443端口
  - http 响应更快，因为 https 需要SSL连接
  - https 需要SSL证书




### TCP、UDP

[面试官：如何理解UDP 和 TCP? 区别? 应用场景?](https://vue3js.cn/interview/http/UDP_TCP.html#%E4%B8%80%E3%80%81udp)

[TCP和UDP比较 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903800336023560)

- TCP 和 UDP 的区别是什么？
  - UDP 无连接，效率高；TCP 需要建立连接，提供可靠传输
  - UDP 没有流量控制、拥塞控制，不保证数据无丢失

- 哪些协议基于 TCP、UDP？
  - 基于TCP的有：HTTP、FTP...
  - 基于UDP的有：DNS、QUCI...

- UDP 应用场景是什么？
  - 实时应用（聊天、直播、视频会议）

- TCP 三次握手四次挥手，https://blog.csdn.net/welnee/article/details/109153129
  - 为什么是三次握手？




### Websocket

[面试官：说说对WebSocket的理解？应用场景？](https://vue3js.cn/interview/http/WebSocket.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88)

- 有什么优点？
  - 实时性更强，服务器不需要等待客户端发起请求就能响应
  - 保持连接状态，创建连接后，可省略状态信息，不同于HTTP每次请求需要携带身份认证
  - 支持扩展，可实现自定义子协议
- 应用场景有哪些？
  - 弹幕
  - 媒体聊天
  - 协同编辑
  - 股票基金报价实时更新





# TypeScript

![image-20231113024624192](/Users/welnee/Library/Application Support/typora-user-images/image-20231113024624192.png)
